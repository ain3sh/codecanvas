\section{Related Work}
\label{sec:related}

\subsection{Terminal-Executed Agent Evaluation}
Terminal-Bench frames agent competence as \emph{end-to-end terminal execution}: agents must navigate containerized environments, run commands, inspect artifacts, and complete multi-step workflows with verifiable outcomes~\cite{terminalbench2025}. Terminal-Bench~2.0 and Harbor emphasize stronger verification and reproducible orchestration~\cite{terminalbench2harbor2025}. Harbor additionally standardizes trajectory logging via ATIF, enabling consistent process-level analyses (tokens, tool calls, observations) across agents and harnesses~\cite{harborATIF2025}.

\subsection{Harness Design and Agent-Computer Interfaces}
Agent performance depends strongly on the agent-computer interface (ACI): action primitives, observation formatting, and feedback channels shape what strategies are feasible and how reliably they execute~\cite{sweagent2024}. Systems such as OpenHands further emphasize deterministic harnesses and sandboxed execution to support reproducible evaluation~\cite{openhands2024}. CodeCanvas targets a narrow, experimentally controlled axis within this space: holding the harness constant (Harbor + Claude Code), we vary only the \emph{observation channel} delivered through MCP tools and deterministic hooks~\cite{claudeCodeHooks2025}.

\subsection{Repository Representations for Search and Localization}
Repository-scale tasks stress context selection: relevant information is distributed across files, interfaces, and dependency structure. Retrieval-centric work focuses on efficient \emph{textual} context selection~\cite{repocoder2023,repoformer2024,repofuse2024}. Complementarily, graph-based representations make structure explicit. RepoGraph provides repository-level graphs to guide navigation~\cite{repograph2024}, and LocAgent constructs heterogeneous dependency graphs and applies multi-hop traversal for localization~\cite{locagent2025}. These systems motivate our graph-based baseline: structural signals can reduce ambiguity and improve search, but they may also impose a query burden and fragment understanding across tool calls.

\subsection{Dependency-Aware Grounding for Correct Edits}
Even with correct localization, agents often fail due to project-context mismatch: invalid API usage, broken dependencies, or refactors that neglect callers and tests. CoCoGen combines compiler feedback with iterative context refinement to improve project-context-dependent code generation~\cite{cocogen2024}. MARIN constrains decoding to valid project APIs by mining hierarchical dependencies~\cite{marin2025}. These approaches share a common principle: \emph{dependency structure} is essential for correctness in realistic codebases. CodeCanvas is complementary: rather than constraining generation, it surfaces dependency impact as an observation \emph{before} edits are made.

\subsection{External Memory and Visual Reasoning Artifacts}
Long-horizon interactive tasks exceed context windows and require maintaining hypotheses, evidence, and decisions across iterations. MemGPT proposes explicit external memory with control flow for long-context settings~\cite{memgpt2023}. In parallel, multimodal work shows that visual intermediate artifacts can improve reasoning when the underlying structure is spatial or graph-like~\cite{whiteboard2024,visualsketchpad2024}. Closest to our setting, visualization can also support monitoring and steering of code-driven workflows~\cite{waitgpt2024}. CodeCanvas combines both ideas: it externalizes reasoning state via an Evidence Board and makes dependency structure consumable via compact codemaps.

\subsection{Positioning}
Prior work establishes the importance of harness/ACI design~\cite{sweagent2024,terminalbench2harbor2025}, structured representations for navigation~\cite{locagent2025,repograph2024}, dependency-aware grounding for correctness~\cite{cocogen2024,marin2025}, and visual artifacts for structured reasoning~\cite{whiteboard2024,visualsketchpad2024,waitgpt2024}. However, there is limited controlled evidence in a \emph{terminal-executed}, fixed-harness setting isolating how \emph{observation modality} (text-only vs.\ graph-derived signals vs.\ visual codemaps) and \emph{persistence via deterministic hooks} affect stability and efficiency. Our work addresses this gap by evaluating these design choices on Terminal-Bench~2.0 under Harbor with Claude Code.
